---
title: 软件工程
description: 
published: true
date: 2023-09-14T08:33:16.102Z
tags: 
editor: markdown
dateCreated: 2023-09-13T06:20:57.474Z
---

# 软件工程

## 0. 面向考试

### 各章考点

第一章：

- [ ] SE基础知识
- [ ] （非重点）开发模式/范式
- [ ] 错误、缺陷与失败
- [ ] 软件质量
- [ ] （非重点）软件系统的系统组成
- [ ] 现代软件工程的几个阶段
- [ ] （非重点）现代软件工程实践发生变化的关键因素
- [ ] 软件过程，重要性，各个阶段
- [ ] 重用、抽象等概念

第二章：

- [ ] 软件过程，重要性，生命周期
- [ ] 瀑布模型及各阶段文档，优缺点
- [ ] 原型的概念和用途
- [ ] 分阶段开发模型的含义，基本分类及特点
- [ ] 螺旋模型四个象限的任务及四重循环的含义
- [ ] UP，RUP，进化式开发的含义
- [ ] 敏捷方法及其代表性方法

第三章：

- [ ] 项目进度，活动，里程碑，项目成本
- [ ] 如何计算软件项目活动图的关键路径，冗余时间，最早和最迟开始时间
- [ ] 软件团队人员应该具备的能力
- [ ] 软件项目团队组织的基本结构
- [ ] 专家估算法的大概含义
- [ ] COCOMO模型的三个阶段
- [ ] 软件风险，主要风险活动，降低风险策略

第四章：

- [ ] 需求的含义
- [ ] 需求阶段确定需求的过程
- [ ] 获取需求时，若有冲突发生如何考虑优先级
- [ ] （非重点）如何使需求变的可测试
- [ ] 需求文档的两类
- [ ] 功能性需求和非功能性需求，设计约束，过程约束
- [ ] （非重点）需求的特性
- [ ] DFD数据流图的构成及画法
- [ ] （非重点）抛弃型原型，演化型原型

第五章：

- [ ] 软件体系结构，设计模式，设计公约，设计，概念设计，技术设计
- [ ] 软件设计过程模型的几个阶段
- [ ] （非重点）三种设计层次及其关系
- [ ] （非重点）模块化，抽象
- [ ] 设计用户界面应考虑的问题
- [ ] 模块独立性，耦合与内聚
- [ ] 复审，设计复审

第六章：

- [ ] 面向对象的概念
- [ ] 设计模式
- [ ] OO设计的基本原则
- [ ] OO开发的优势
- [ ] OO开发过程的步骤
- [ ] 用例图的组成和画法
- [ ] 用例模型建模
- [ ] 类图的组成和画法
- [ ] （非重点）状态图的含义及用途

第七章：

- [ ] （非重点）为什么说编码工作是纷繁复杂甚至令人气馁的
- [ ] 一般性的编程原则
- [ ] （非重点）编码阶段实现某种算法所涉及的问题
- [ ] 编写程序内部文档时需要添加的注释信息
- [ ] 敏捷方法的大致思想，极限编程，派对编程

第八章：

- [ ] 软件产生缺陷的原因
- [ ] （非重点）软件缺陷进行分类的理由
- [ ] 几种主要的缺陷类型
- [ ] 正交缺陷分类法
- [ ] 测试的各个阶段及其任务，涉及的文档
- [ ] （非重点）测试的态度问题
- [ ] 掌握测试的方法
- [ ] 单元测试
- [ ] 黑盒测试方法的分类，测试用例的设计方法
- [ ] 白盒方法的分类，覆盖方法
- [ ] 集成测试及其主要方法的分类
- [ ] 传统测试和OO测试的区别
- [ ] （非重点）测试计划设计的步骤

第九章：

- [ ] 系统测试的主要步骤及各自含义
- [ ] （非重点）系统配置，系统配置管理
- [ ] 回归测试
- [ ] 功能测试的含义及其作用
- [ ] 功能测试的基本指导原则
- [ ] 性能测试的含义与作用
- [ ] 性能测试的主要分类
- [ ] （非重点）可靠性、可用性和可维护性
- [ ] 确认测试的概念，分类
- [ ] Alpha测试，Beta测试
- [ ] 安装测试

## 1. 软件工程简介

推迟实现是软件方法学的基本指导思想：尽可能推迟软件的物理实现（而不是逻辑实现）。

软件危机：开发软件所需的高成本和软件的低质量之间有尖锐的矛盾。

### 基础知识

软件工程：以计算机科学理论和计算机功能为基础，使用合适的工具、技术、管理方式、设计范式等手段，产出软件解决现实问题的综合过程。软件工程即用**系统科学**的**工程性方法**解决软件开发时遇到的问题，也就是，将**系统化的、严格约束的、可量化**的方法应用于软件的开发、运行和维护。

- 目的：规范软件**开发流程**，推出能解决实际问题的高质量的软件产品。
- 分析：分析所遇到的问题，从以往案例的成功与失败两方面进行分析、获取经验、解决问题。
- 设计：对问题给出解决方案。
- 开发团队：组成团队进行开发，要具体描述团队中每个人的角色和职责。
- 开发：实现我们设计的解决方案。
- 项目管理：将一个大的系统分为小的部分，明确开发过程，控制开发进度，应对种种变化。
- 作用：降低开发成本，达到要求的软件功能、提高软件性能、提高软件的可移植性、降低维护费用、按时完成工作并交付使用

### 开发模式/范式

常用的软件开发模式有四种：1、瀑布开发模式；2、迭代式开发模式；3、螺旋开发模式；4、敏捷开发模式；

### 软件异常与质量

> 这部分存在一些争议

- 错误（Error）：在软件开发过程中的错误，停留在**需求工作和编码过程**中，例如：误解了需求，敲错了代码。

- 缺陷（Fault）：存在于软件（文档、数据、程序）之中的那些**不希望或不可接受的偏差**。由于错误而引起的，存在于某些功能实现处的问题，属于**功能实现**层面，例如：对需求的误解导致的需求文档错误和与设计意图不相符的设计，敲错代码导致的错误的功能实现 （缺陷是错误的结果/表现）。

  软件缺陷的主要特征：

  - 软件未达到软件产品需求说明书指明的要求。
  - 软件出现了软件产品需求说明书中指明不应出现的错误。
  - 软件功能超出软件产品说明书指明的范围。
  - 软件未达到软件产品说明书未指明但应达到的要求。
  - 软件测试人员认为难以理解、不易使用、运行速度慢或最终用户认为不好。

- 软件故障：在一个计算机程序中出现的不正确的步骤、过程或数据定义常称为故障。是指**软件运行时丧失了在规定的限度内执行所需功能的能力，执行输出错误结果，导致失效**。

- 软件失效：是指**软件运行时产生的一种不希望或不可接受的外部行为**，偏离了用户需求。

软件错误、缺陷、故障和失效：

- 软件错误是一种人为错误。**一个软件错误必定产生一个或多个软件缺陷**。
- 当一个软件缺陷被激活时，便产生一个软件故障；同一个软件缺陷在不同条件下被激活，可能产生不同的软件故障。
- 软件故障如果没有容错措施加以处理，便不可避免地导致软件失效；同一个软件故障在不同条件下可能产生不同的软件失效。

软件故障和失效的比较：

| 软件失效                       | 软件故障                     |
| ------------------------------ | ---------------------------- |
| 面向用户                       | 面向开发者                   |
| 软件运行时偏离用户需求         | 程序执行输出错误结果         |
| 根据对用户应用的严重性等级分类 | 根据定位和排除故障的难度分类 |

软件质量可以从以下三个方面衡量：

1. **产品质量**：从用户看来，高质量软件需要有充实的功能且便于学习上手从开发者来看，高质量软件需要有良好的内部特性，比如缺陷要少。
2. **过程质量**：许多软件开发活动都会引起最终产品质量的变化，所以过程也存在质量指标。我们有量化过程质量的参数，比如CMM。
3. **商业价值**：技术价值以技术指标衡量，如：速度、维护成本等然而软件的技术价值并不一定能转化为商业价值，公司并不一定会认为一个软件与自己的商业战略吻合，商业价值是一个独立的领域。

产品质量的标准包括：

- 用户：功能足够，易于上手。
- 开发者：衡量软件的内部特征，例如缺陷的数量。

过程质量的标准涉及软件过程中发生的事件，他们会影响过程的质量，并最终影响软件的质量，量化的方法包括CMM等。

> CMM（Capability Maturity Model，能力成熟度模型）是一种用于评估和改进软件工程组织过程质量的方法。CMM定义了五个成熟度级别，每个级别描述了组织在软件过程管理方面的不同能力水平：
>
> 1. 初始级别（Level 1 - Initial）：过程是无序的，项目的成功依赖于个别人员的能力和努力。
> 2. 可重复级别（Level 2 - Repeatable）：过程已经被定义，并且在项目中得到了重复使用。组织开始建立基本的项目管理控制。
> 3. 定义级别（Level 3 - Defined）：过程已经被标准化，并在整个组织范围内得到了统一的应用。组织能够根据标准过程执行项目。
> 4. 管理级别（Level 4 - Managed）：过程已经被量化和统计，并进行了过程管理和控制。组织能够通过度量和分析来预测项目的结果。
> 5. 优化级别（Level 5 - Optimizing）：过程已经通过持续的改进得到优化。组织能够根据量化的数据和经验教训来改进过程。

商业价值的标准包括：

- 技术价值：各种技术指标。
- 商业价值：机构对于软件是否与其战略利益相吻合的一种战略评估。
- 目标：将技术价值和商业价值进行统一。

### 现代软件工程的构成

现代软件工程大致包含如下阶段：

1. **需求定义与分析**：进行问题定义与可行性分析得出文档：SRS（软件需求规格说明书）
2. **系统设计**：设计用户界面，进行顶层设计得出文档：SAD（系统架构图？软件体系结构图）
3. **程序设计**：描述模块功能算法与数据描述，处于伪代码阶段得出文档：模块功能与数据描述文档
4. **程序实现**：进行编程与调试得出文档：源代码、注释、源代码文档
5. **单元测试**：按程序设计阶段的文档（模块功能与数据描述文档）进行测试
6. **集成测试**：按SAD进行测试
7. **系统测试**：按SRS进行测试得出文档：以上三个测试得出各自阶段的测试报告
8. **系统提交**：用户交付，必要时指导用户如何使用得出文档：用户手册、操作手册
9. **维护**：修改软件的过程，不断进行改错和满足新需求得出文档：维护记录

使现代软件工程实践发生变化的关键因素：

1. 商业软件投入市场实践的紧迫性
2. 计算经济学的改变：更低的硬件成本，更高的开发、维护成本
3. 强大的桌面平台计算的可用性
4. 广泛的局域网和广域网
5. 面向对象技术的出现和应用
6. 图形界面的使用
7. 软件开发瀑布模型的不可预测性

**软件过程**是软件开发活动中的**各种组织及规范方法**。他的重要性体现在：

1. **通用性**：软件过程可以让一系列开发活动保持一致性和结构性
2. **指导性**：软件过程使我们可以分析、检查、理解、控制和改善软件开发活动。
3. 可以把获得的经验传递给其他人。

软件工程涉及的其他主要概念：

1. 重用：重复采用以前开发的软件系统中具有的共性部件，用到新的开发项目中去。
2. 抽象：基于某种层次归纳水平的问题描述。它使我们将注意力集中在问题的关键方面而非细节。
3. 分析、设计方法和符号描述系统：使用标准来对程序进行描述，利于交流和建模并检查其完整性和一致性，利于重用。
4. 用户界面原型化：建立系统的小型版，通常具有有限的关键功能，以利于用户评价和选择，帮助我们确认关键需求，证明设计或方法的可行性。
5. 测度和度量：通用的评价方法和体系，有助于使过程和产品的特定特性更加可见，包括量化描述系统、量化审核系统。
6. 工具和集成环境：通过框架比较软件工程环境提供的服务，以决定其好坏，并且将各个阶段使用的工具集成起来。工具成必须处理一下五个问题：
   - 平台集成：工具必须在异构的网络中能相互操作相互配合
   - 表示集成：这些工具应当有统一的用户界面
   - 过程集成：工具与开发过程间要有联系
   - 数据集成：工具间要有共享数据的方式
   - 控制集成：工具间要有彼此交流，彼此通知对方并启动另一个工具的动作的能力
7. 软件体系结构：定义一组体系结构单元及其相互关系集来描述软件系统。

## 2. 项目过程建模与生命周期

## 3. 计划与实施项目

## 4. 软件需求

## 5. 软件系统设计

## 6. 面向对象

## 7. 编写程序

## 8. 测试程序

### 软件缺陷

软件产生缺陷的原因：

- 系统本身有太复杂的部分
- 客户不清晰的需求
- 设计阶段就存在缺陷
- 其他因素（规模、参与者过多）
- 不是客户真正想要的软件，**错误的需求**。
- 缺失若干事件处理逻辑。
- 软件需求无法实现。
- 曲解需求、设计本身问题等。
- 代码在某些条件下有运行隐患。
- 将设计予以实现时方法不当。

为何要对软件缺陷进行分类：系统中不存在明显的故障时，我们就需要对程序进行测试，创造一些条件以期让代码不能像计划那样做出反应，看看有没有更多故障。而为了更容易发现这些故障，为故障进行分类时很重要的。

主要的缺陷类型：

- 算法缺陷：算法某些处理步骤或逻辑有问题，导致软件的部件**对于输入数据不能给出正确的输出**；
- 计算和精度缺陷：算法或公式在编程实现时逻辑没错，但是**计算过程出现了错误或者精度达不到要求**，从而无法获取正确输出；
- 过载缺陷（压力缺陷）：程序运行时**，数据填充量会超过数据结构的规定容量**引起的缺陷；
- 能力缺陷（边界缺陷）：**系统活动量达到系统极限时，系统性能变的不可接受**，称为能力缺陷；
- 性能缺陷（吞吐量缺陷）：系统在**常规状态下就不能以需求规定的速度执行**；
- 时序性缺陷（协调缺陷）：几个**同时或有严格执行顺序的进程协调**出现问题；
- 文档缺陷：**文档描述与程序实际行为**不符；
- 恢复性缺陷：系统失效时，**程序无法再恢复**也是一种缺陷；
- 硬件和系统软件缺陷：作为**底层支持的硬件和系统软件没有按照文档中的操作条件和步骤运作**时，也可引起软件的问题；
- 标准和规格缺陷：代码**没有遵守组织机构的标准和过程**。这个缺陷最大的影响在于：不按照标准的代码可能在测试和修改时让人不好理解，引起问题。

正交缺陷分类：使任意一个缺陷只属于一个类别的缺陷分类方案称为正交缺陷分类。

> 如果故障属于不止一个类，则失去了度量的意义。

### 测试过程

![测试过程的步骤](https://s2.loli.net/2023/12/13/tEfJLPF2O7uY35K.png)

测试的各个阶段如上图所示，具体包括：

1. 单元测试：验证组件的功能。依据文档：程序代码与配套文档
2. 集成测试：验证系统组件是否能正确的协同工作。依据文档：系统体系结构文档SAD、程序设计规格说明
3. 功能测试：验证系统是否能执行需求规格说明中描述的功能。依据文档：软件需求规格说明书SRS
4. 性能测试：验证系统的软硬件表现和性能是否符合需求规格说明文档。这一步之后，软件系统应当能在客户的实际工作环境中成功执行，这时我们说产生了一个被确认的系统。依据文档：软件需求规格说明书SRS
5. 验收测试：验证系统是否满足了客户的需求定义（**需求定义和需求规格说明是有区别的**）。依据文档：客户需求定义
6. 安装测试：验证系统能否在用户使用的真实环境中安装并正常运行。依据文档：用户环境的说明
7. 系统测试：功能测试、性能测试、验收测试和安装测试统称为系统测试。

#### 黑盒测试与白盒测试

黑盒测试：人员在完全不了解程序内部的逻辑结构和内部特性的情况下，只依据程序的需求规格及设计说明，检查程序的功能是否符合它的功能说明。其**原则是依据系统需求文档、系统设计文档、程序设计文档进行测试**，正确的结果是系统完成了所有该做的，拒绝了一切不该做的。

- 优点：测试人员不受程序所带来的束缚，测试更具有客观性
- 缺点：有时会无法进行完备的测试，在不知道程序内部逻辑的情况下，设计测试时就可能无法面面俱到

白盒测试：人员拥有全套文档，以程序内部结构为基本依据，手动或自动进行测试

- 优点：有助于进行更细致、切中要害的测试
- 缺点：全路径、极度细致的测试不现实

黑盒测试的分类方法包括如下四种：

- 等价分类法：输入域划分为若干等价类，并且从每个等价类里选择有代表性的少量用例代表其余所有情况。其根本逻辑在于：**如果这些代表性用例没有出现问题，那么其他的一般也没有问题**。
- 边界值分析法：在等价分类法的基础上，把测试值选在等价类的边界上，经验告诉我们这往往有更好的效果。
- 错误猜测法：根据测试人员的经验，猜测程序中哪些地方容易出错，并补充出用例；此方法适合作为其他方法的补充。
- 因果图法：适用于被测试程序有很多输入条件，程序的输出又依赖输入条件的各种组合的情况。

等价分类法中，等价类可以分为有效等价类和无效等价类两种，前者是正常输入，后者是不应当输出正确结果的无效输入。在划分等价类时，需要尽可能“密铺”式划分，并且尽可能不对测试的实体整体添加限制条件以提升可扩展性。

对有效等价类的用例，**尽量用一个用例覆盖尽可能多的等价类**，这是因为任意一个有效等价类的处理出现问题都会产生故障，被我们发现，我们可以以此减少测试次数；对无效等价类，必须为每一个无效等价类都设计一个专内验证该点的用例，这是因为所有无效等价类的表现都是不正常返回，不进行共用以避免多个错误一起发生导致漏过一些错误。用例可以进一步区分为如下三种：

- 弱一般等价类：测试每个一般等价类都至少出现在用例中一次即可。

  > 基于单缺陷假设：**失效很少因为两个或更多缺陷同时共同引发**。

- 弱健壮等价类：考虑有效等价类之外，划分出的无效等价类，并且每个等价类在用例中至少出现一次即可；仍基于单缺陷假设。

- 强一般等价类：测试用例应当遍历等价类的所有笛卡尔积组合；基于多缺陷假设。

白盒测试的方法包括两种：

- 逻辑覆盖法
- 路经测试法

逻辑覆盖法是一组逻辑覆盖方法的统称，按照程序逻辑覆盖程度分为：

- 语句覆盖：每条语句至少执行一次
- 判定覆盖（又称分支覆盖）：每一分支至少执行一次，又称分支覆盖
- 条件覆盖：每个条件均按“真”和“假”两种结果至少执行一次
- 条件组合覆盖：某个分支的虽然只有一种结果，但可能由多个条件组合而成。条件覆盖只要求单个条件一次真一次假即可，条件组合覆盖要求覆盖所有组合，即使有些组合最终结果一样。

路经测试法借助程序图设计测试用例，包括四种：

- 结点覆盖：经过所有结点，相当于逻辑覆盖中的语句覆盖。
- 边覆盖：覆盖所有边，相当于逻辑覆盖中的判定覆盖。
- 完全覆盖：同时满足结点覆盖和边覆盖，也即走过所有位置，这是**测试简单程序的最低标准**。
- 路径覆盖：程序图中每条路径都至少经过一次。路经覆盖法与穷举测试有所不同，路径覆盖法并不关注循环次数，某个循环语句循环1次和n次对于路径覆盖法是一样的，但是穷举测试则认为它们是不同的。

### 单元测试

单元测试：将每个程序构件与系统中其他构件隔离，对其单独进行测试。

在集成测试及以后的阶段，除去很小的程序，都应当使用黑盒。这一具体流程包括：

- 使用边值分析法或等价分类法提出基本的测试用例
- 使用猜错法补充一些测试用例
- 如果在程序的功能说明中含有输入条件的组合，宜在一开始就用因果图法，然后再按以上两步进行

对于单元测试，我们往往可以直接参考模块的源代码，并且工作量可以承受，所以宜采用黑盒法白盒法结合运用——先使用黑盒法设计测试用例，然后使用白盒法进行补充，达到我们期望的覆盖标准。

### 集成测试

集成测试验证系统组件**是否能正确的协同工作**，选择策略要兼顾系统特性和客户需求。

- 驱动模块：代替上级模块传递测试用例的程序（出现在自底而上集成测试中）
- 桩模块：代替下级模块的仿真程序（出现在自顶向下）

集成测试的方法有四种：

- 自底向上的集成测试：从模块结构图的最底层开始，**由下而上按调用关系逐步添加新模块**，组成子系统分别测试，直到全部组装完毕；典型特征是：添加的新模块调用的下层模块都必须被全部测试完毕、 使用驱动模块。
- 自顶向下的集成测试：从顶层控制组件开始进行测试，然后**逐步将调用的下级组件组合起来**，再对更大的子系统测试，直到全部组装完毕；典型特征是：添加的新模块，调用它的上层模块必须被测试过、 使用桩模块。
- 莽撞测试：先测试每一个模块，之后将所有模块一并集成。
- 混合方式/三明治方式测试：从上到下将模块分为三层：上层、目标层、下层。上层自顶向下，下层自底向上，中层直接使用驱动模块+桩模块独立测试，最后集成三层，测试集中于目标层。

### OO测试

传统测试与OO测试的区别：

1. 传统测试：当系统改变时，需要新老测试用例（回归测试），只需要推出新的测试用例即可。
2. OO测试：必须对重载的子类进行测试，可能会使用不同的测试用例。
3. OO测试，在单元测试中更加简单（对象的粒度更小），但是集成测试更难（设计接口、继承、多态等）

OO测试面临如下四个困难：

1. 需求验证缺乏工具支持。（很多时候依赖人工）
2. 测试工具生成的测试用例，处理OO模型中的对象和方法时，其针对性不强。（某些OO关系是测试工具本身搞不清楚其内在逻辑关系的）
3. 传统的测试方法（如环路复杂度等）在评价OO系统的规模和复杂性时，还不是很有效。
4. 对象的交互是OO系统复杂性的根源，传统的测试方法和根据作用有限。

## 9. 测试项目

### 系统测试

![系统测试步骤](https://s2.loli.net/2023/12/14/S46aC9qp2ZMrGQe.png)

系统测试的过程如上图所示，具体步骤包括：

- 功能测试：验证系统是否能执行需求规格说明SRS中描述的功能；依据文档：软件需求规格说明书SRS。
- 性能测试（非功能性需求）：验证系统的软硬件表现和性能是否符合需求规格说明文档这一步之后，软件系统应当能在客户的实际工作环境中成功执行，这时我们说产生了一个被确认的系统；依据文档：软件需求规格说明书SRS。
- 验收测试：验证系统是否满足了客户的需求定义（需求定义和需求规格说明是有区别的）；依据文档：客户需求定义。
- 安装测试：主要解决开发环境和用户环境的不同导致的问题，验证系统能否在真实环境中安装并正常运行；依据文档：用户环境的说明。

系统配置是指交付给特定客户的一系列部件的集合；软件配置管理指对系统不同的软件配置的管理及控制方法（即有开发、也有测试），通过控制系统差别以降低风险、减少错误；基线指软件文档和其他资料的集合，代表了产品在某一时间点的情况。

回归测试是用于新版本的一种测试，验证它与旧版本相比，是否仍以相同的方式执行着相同的功能。

### 功能测试

功能测试的作用：以高检测率发现缺陷（因为一项功能测试只面向一小组组件，不容易导致多个缺陷彼此掩盖）。

功能测试的基本指导原则：

- 要具有较高的查错率
- 使用独立的测试团队
- 了解预期的输出结果
- 对合法和非法输入都进行测试
- 不能为了测试方便而去修改系统
- 制定测试停止的标准

### 性能测试

性能测试的作用：确保系统的可靠性、可用性和可维护性。

性能测试的主要分类包括如下13种：

1. 压力测试/强度测试：短时间内加载极限负荷，验证系统能力，对经常产生负荷高峰的系统很有意义
2. 容量测试/巨额数据测试：验证系统处理巨量数据的能力
3. 计时测试：评估涉及对用户的响应时间以及功能执行耗时的相关需求
4. 配置测试：对系统软硬件的各种配置进行测试
5. 兼容性测试：测试其接口在与其他系统互动时能否正常运作
6. 环境测试：测试系统在安装场所的执行能力，这里指的是外部的物理条件，比如高温、潮湿
7. 回归测试：验证软件的新版本与旧版本相比，是否仍能以相同的方式执行着相同的功能
8. 安全性测试：确保安全性需求得到满足
9. 质量测试：评估系统的可靠性、可维护性和可用性
10. 恢复测试：检验系统是否能在故障或丢失电源、数据、设备时自我恢复
11. 维护测试：核验一些诊断工具和过程是否能正常运行，如：诊断程序、事务跟踪、辅助工具
12. 文档测试：确保编写了必要的文档
13. 人为因素测试/可用性测试：检查设计系统用户界面的需求

测试需要考虑的三个性能：

- 可靠性：软件系统在给定的时间范围和条件下运行成功的概率
- 可用性：软件系统在给定的时间点成功运行的概率可用性强调某一时刻系统正常，系统可能在相当长一段时间内都可用，保持了可靠性，但在不能使用（例如检修）的那一刻，它失去了可用性
- 可维护性：是指在给定的使用条件（包括：预定的时间间隔、可用的维护程序、可用的维护资源之下进行维护）下，维护活动能被执行的概率

### 验收测试

验收测试由客户检查软件系统是否满足了他们的需求定义，主导者是客户，开发者只负责解答一些必要的问题。

有三种分类：

- 基准测试：先由用户准备测试用例，然后在实验环境中安装系统，最后由用户进行评估

- 引导测试：先将系统安装在实验环境中，然后在假设系统正式安装的前提下，由测试者在测试系统上进行日常工作，而不是依赖于测试用例；$\alpha$测试和$\beta$测试都属于引导测试。

  > $\alpha$测试：由开发者自己组织人员或委托专业团队来进行小规模测试；$\beta$测试：由客户实际进行小规模测试

- 并行测试：当软件的一个旧版本正在使用，并且要测试一个新版本时使用；新旧版本并行运转，来自用户的操作会同时在新旧系统上执行，旧系统实际工作，新系统进行测试，使用户逐渐习惯新系统
