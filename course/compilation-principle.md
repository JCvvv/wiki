# 编译原理

## 大纲

### 题型

一共六个大题：

1. 概念题
2. 词法分析
3. 语法分析（自上而下和自下而上俩题）
4. 中间代码生成
5. 代码生成+优化

### 各章考点及历年考试覆盖内容

按课本知识顺序（也是编译原理的工作顺序）从前往后组织这部分内容。

#### 1. 基础概念

只会出前面的概念/简答题。

- 自动机/正规式/正规集的概念
- 句子/句型/文法的概念
- 中间代码生成的概念，方法及优缺点
- 基本块/流图的概念
- 活动记录/内存分配方式
- 参数传递方式，1）传值，2）传地址，3）传名，4）传地址+值的结果
- 等等

#### 2. 词法分析

词法分析核心知识在于“正规集->正规式->DFA”的过程，需要掌握化简方法，占一个大题。

#### 3. 语法分析

语法分析出两道大题，分别是自上而下和自下而上方法。题目会给文法，要求给出分析表。

- 自上而下的语法：递归下降和`LL(1)`
- 自下而上的语法都是LR语法，包括`LR(0)`（重点），`SLR(1)`（重点），`LR(1)`，`LLR(1)`

#### 4. 语法制导翻译

只会出概念题。

#### 5. 中间代码生成

出一道大题，解决从语句 -> 中间代码的问题。

#### 6. 代码生成+优化

1. 给一个基本块
2. DAG优化（局部优化）
3. 生成汇编语言代码

## 词法分析

### 词法分析器的作用

- 扫描字符流，滤掉空白符、换行符、制表符、注释等，分离出词素，输出词法单元序列
- 将词素添加到符号表中(可选)
- 在逻辑上独立于语法分析，但是通常和语法分析器处于同一趟中

与语法分析的关系如下：

![词法分析位置](https://s2.loli.net/2023/11/13/FCX3H6fGMpsyNzT.png)

**独立的**词法分析器可以：

- 简化编译器的设计
- 提高编译器效率
- 增强编译器的可移植性

在词法分析部分，字符串、正则表达式、语言、自动机和词法分析器的关系如下图所示：

![词法分析部分的整体关系](https://s2.loli.net/2023/12/03/IvT2ecELyFzAqP1.png)

### 词法单元的模式（正则表达式）

#### 词法单元的模式

词法分析器中包含两个要素：

- 词素 (lexeme)：源程序中**一段连续的字符序列**；我们感兴趣的是**满足一定规则（模式）的词素**，有了模式才有识别的依据。
- 词法单元 (token)：对于**满足某一种模式的词素**，归为一类，类名即是token名
  `token = ⟨token名、属性值⟩`；下一阶段的语法分析器通过 token 名即可确定**程序的语法结构**；**属性值通常用于语义分析及之后的阶段（语法制导翻译）**；属性值是可选的，即可以有，也可以没有。

当**一个`token`对应多个词素**时，必须通过**属性来传递附加的信息**。属性值将被用于后面的语义分析、代码生成等阶段，不同的token需要不同的属性。

如何选择词法单元（通常情况下）：

- 每一个关键词给一个自己的token。
- 每一个标点符号给一个自己的token
- 将标识符归为一组，给一个自己的token
- 将数字常量归为一组，给一个自己的token
- 将字符串归为一组，给一个自己的token
- 空白符、换行符、回车符、制表符一概不予理会

#### 正则表达式

**正则表达式**可以用来快速识别词法单元对应的模式。

字符与字符串相关的概念包括：

- 字母表：一个有限的符号集合。

- 串及相关术语：字母表中符号的优先序列。相关术语还包括：

  - 前缀
  - 后缀
  - 子串：删除串的某个前缀和某个后缀得到的串。
  - 真前缀、真后缀、真子串
  - 子序列：从原串中删除0个或多个符号后得到的串。

  串的运算有：

  - 连接
  - 指数运算（幂运算）

- **语言**：某个**给定字母表上的串的可数集合**。相关运算包括：

  - 并
  - 连接
  - Kleene闭包
  - 正闭包

- 正则语言：可以用一个正则表达式定义的语言。

编程语言通常需要**同时处理多种模式**，即多个正则表达式，为方便起见，引入“**变量**”，给一些正则表达式命名，并在**之后的正则表达式中像使用字母表中的符号一样使用这些名字**。正则定义是如下形式的定义序列：

$$
{d_1} \rightarrow {r_1} \\
{d_2} \rightarrow {r_2}
$$
其中：

- $d_i$：表示一个新符号。
- $r_i$是一个正则表达式。

> 引入正则定义及运算符扩展的唯一目的就是使正则表达式更简洁，而其描述能力并无增强。

![C语言的正则定义示例](https://s2.loli.net/2023/12/03/TUF4OSZhwCtlkD2.png)

### 词法单元的识别

#### 词法单元的识别方法

词法分析器要求**能够检查输入字符串，在其前缀中找出和某个模式匹配的词素，进而获得token**。这个识别过程中词法分析器可能处于若干已经确定的状态中，最终到达一个结束态获得一个对应的token。

首先通过正则定义来**描述各种词法单元的模式**，然后构造状态转换图（在纸上，或者在你脑海里），用程序模拟状态转换图的状态转换过程。

状态转换图由两部分构成：

- 状态：表示在词素识别过程中可能出现的情况。
  - 可以看作是**对前一部分字符串处理情况的总结**；
  - 某些状态为**接受状态或最终状态，表明已找到词素**；
  - 加*的接受状态表示最后读入的符号不纳入词素；
  - **开始状态 (初始状态)**：用start边表示。
- 边：从一个状态指向另一个状态。
  - 边的标号是一个或多个符号；
  - 若当前状态为`s`，下一个输入符号为`a`，就沿着从`s`离开，标号为`a`的边到达下一个状态。

![状态转换图示例](https://s2.loli.net/2023/12/03/JabVGcdYOMlq3zw.png)

作用：**词法分析器的主要代码就是模拟状态转换图的运行过程**。

在词法分析中，状态表示**词法分析器在处理输入字符串时所处的状态**。这些状态反映了词法分析器的内部状态，例如正在识别某个词法单元的一部分，或者已经识别完整的词法单元等。通过状态转换图，可以清晰地表示词法分析器在不同状态下对输入字符的处理方式，以及状态之间的转换条件。状态转换图可以以多种形式存在于编译器中，其中两种常见的形式是：

1. 图形表示：状态转换图可以在纸上画出，或者以图形的形式在计算机中呈现。在图形中，每个状态用节点表示，每条边表示状态之间的转换关系。边上标记的字符表示触发状态转换的输入字符。
2. 数据结构表示：在计算机程序中，状态转换图可以用数据结构来表示。常见的数据结构包括**有限状态自动机（Finite State Automaton）**和**状态转换表（Transition Table）**。有限状态自动机是一种抽象的数学模型，可以用于表示状态和状态之间的转换关系。状态转换表是一种表格形式的数据结构，用于存储状态转换图的信息，包括当前状态、输入字符和下一个状态。

无论是图形表示还是数据结构表示，状态转换图都提供了一种清晰的方式来描述词法分析器的状态和状态之间的转换关系。通过状态转换图，词法分析器可以根据当前状态和输入字符，确定下一个状态，并根据状态转换图的定义进行状态转换。这样，词法分析器就能够逐步解析输入字符串，并识别出其中的词素。

![状态转换图示例2](https://s2.loli.net/2023/12/03/OC74RFoBNaS6hYf.png)

#### 保留字和标识符的识别

在很多时候，**关键词也符合标识符的模式**，导致识别标识符的状态转换图也会识别关键词。

两种解决方法：

1. 在符号表中先填关键词，并指明它们不是普通标识符
2. 为保留字建立独立的、高优先级的状态转换图

#### 词法分析器的体系结构

根据前面的分析，通过设计语法及对Token的正则表达进行设计，可以得到一个状态转换图用来识别输入串的模式（也就是获得Token），而词法分析器的工作就是模拟这个根据状态转换图分析输入串所属Token的过程，因此需要从状态转换图构造词法分析器的方法：

1. 变量`state`记录当前状态。
2. 一个`switch`根据`state`的值转到相应的代码。
3. 每个状态对应于一段代码。这段代码根据读入的符号，确定下一个状态；如果找不到相应的边，则调用`fail()`进行错误恢复。
4. 进入某个接受状态时，返回相应的词法单元。注意状态有`*`标记时，需要回退`forward`指针。

### 词法分析器生成（有限状态自动机为主）

#### 词法分析器的构建步骤

如前面体系结构所描述，词法分析器的构建步骤包括：

1. 选择词法单元。

2. 给出词法单元的正则表达式。

3. 将正则表达式转换为**有限状态自动机**。

   > 这一步可以手工完成也可以使用Flex等生成工具完成。

4. 以有限状态自动机为基础设计词法分析程序。

![词法分析器的构建过程](https://s2.loli.net/2023/12/03/3ZnKMTd5tO9sxQD.png)

> 有限自动机是一种偏数学的算法描述手段，它与正则表达式的关系极其密切，而token的模式恰好用正则表达式描述。很自然地，就可以以有限自动机为基础设计token 的识别过程。概括之，有限自动机是实现词法分析器的基础。

#### 有限自动机

本质上和状态转换图相同，但有限自动机只回答Yes/No。分为两类：

- 非确定有限自动机：对边上的标号没有限制，一个符号可以出现在离开同一个状态的多条边上，$\epsilon$可以做标号。
- 确定有限自动机：对于每个状态以及每个标号，有且只有一条边（或最多只有一条边）。

> FA边上的标号也就是字母表中的符号。

两种自动机的功能是一致的，前者能识别的模式后者也一定能识别；同理亦然。

一个**自动机接受的输入串**，当且仅当存在一条从开始状态到某个接受状态的路径，且该路径各条边上的标号按顺序组成该串。

![自动机接受串的示例](https://s2.loli.net/2023/12/03/jaVfSerHZ8dxPgT.png)

同理，**自动机接受的语言**就是从开始状态到达接受状态的所有路径的标号串的集合。

NFA的定义包括如下部分：

- 一个有限的状态集合
- 一个输入符号集合
- 转换函数
- 一个被指定的开始状态
- 一组被指定为接受状态的接受状态集合

一个NFA的示例（包括正则、NFA图和转换表）如下：

![NFA简单示例](https://s2.loli.net/2023/12/03/5LtXivDy7zjTm4s.png)

一个体现出“NFA”的例子：

> 其中状态“a”出现在离开状态0的两条边上。

![NFA是“NFA”的例子](https://s2.loli.net/2023/12/03/oTsiAzD9aQ5jwgI.png)

DFA是一种特殊的NFA，他们的差异在于：

- 没有$\epsilon$的转换
- 不会有多个离开统一状态的相同标号的边

显然，判断一个串能否被DFA接受要比NFA更高效；而且每一个NFA都有与之等价的DFA存在。

![相同正则的DFA表示](https://s2.loli.net/2023/12/03/qgchGOsrEbJ8tNB.png)

#### 正则表达式到自动机

通过正则表达式，可以确定出一个DFA进行模式匹配，其过程包含两步：

- 正则表达式 -> NFA：Thompson算法
- NFA -> DFA

从正则表达式构建NFA的过程，基本思想是根据正则表达式的递归定义，按照正则表达式的结构，递归地构造出相应的NFA。具体来讲包括两步：

- 构造`\epsilon`的**单个符号**的NFA
- 对于每个正则表达式运算，通过**组合**的方法构建相应的NFA

构造过程略过，对多个NFA的合并方法如下：

- 引入**新的开始状态**，并引入从该开始状态到各个原开始状态的$\epsilon$转换，得到具有多个接受状态的新NFA
- 新NFA接受的语言是原来各个NFA所接受语言的**并集**
- 新NFA中不同的接受状态代表**不同的模式**

> 按照Thompson算法构造的NFA都只有一个接受状态，但是合并步骤会使新NFA出现多更多接受状态。

从NFA到DFA使用子集构造法完成，这个算法包含三个函数：

| 操作                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| $\epsilon-closure(s)$ | 能够从 NFA 的状态$s$开始，只通过$\epsilon$转换到达的 NFA 状态集合 |
| $\epsilon-closure(T)$ | 能够从$T$中的某个 NFA 状态$s$开始，只通过$\epsilon$转换到达的 NFA 状态集合，即$\cup_{s\in T}\epsilon-closure(s)$ |
| $move(T,a)$           | 能够从$T$中的某个 NFA 状态$s$出发，通过标号为$\epsilon$的转换到达的 NFA 状态集合 |

算法描述如下图所示：

![子集构造算法](https://s2.loli.net/2023/12/03/sKq4O1wzIhpbjD9.png)

但是子集构造法不一定得到最简DFA，如图所示：

![构造出的非最简DFA](https://s2.loli.net/2023/12/03/HdDx5w2G8ucKLZ9.png)

理论上，最坏情况下DFA的状态个数会是NFA状态个数的指数多个。

DFA的接受状态所对应的NFA状态子集中至少包括一个NFA的接受状态。如果**其中包括多个对应于不同模式的NFA接受状态， 则表示当前的输入前缀对应于多个模式，存在冲突**，解决方式：找出**第一个列出的这样的模式，将该模式作为此DFA接受状态的输出**。

最后通过Hopcroft算法获得最小DFA。通过DFA的最小化, 可得到状态数量最少的DFA  (不计同构，这样的DFA是唯一的)。

最小化DFA的基本问题是状态之间的可区分关系：

- 如果存在串$x$，使得从状态$s_1$和$s_2$，一个到达接受状态，而另一个到达非接受状态，那么$x$就区分了$s_1$和$s_2$
- 对于两个状态$s_1$和$s_2$，如果存在某个串区分了$s_1$和$s_2$，我们说$s_1$和$s_2$是可区分的， 否则它们是不可区分的

> 可区分状态可以理解为两个（或多个）状态根本不是一类，根据下一个输入的符号，不同状态得到的结果可能会出现不同。而**不可区分状态就是，这两个（或多个）状态，无论下一个接收的符号是什么，得到的结果都是一样的**。

Hopcroft算法的基本思想，要理解需要对抽象代数略作回忆：

- 发现：原DFA状态之间的“不可区分”关系满足自反、对称、传递三个性质，因此是**等价关系**。
- **先确定状态**，首先构造新DFA的两个状态，分别对应**原DFA的接受状态集合**和**非接受状态集合**，这两个集合可能不是等价类；Hopcrof算法的目标（也是过程）就是**根据每个集合中原DFA状态之间是否可区分，将之分裂，直到每个集合都成为（基于不可区分关系的）等价类**为止。
- **再确定转换**，即根据原DFA中状态之间的转换关系，确定新DFA状态之间的转换关系

## 语法分析

### 语法分析器的作用

### 上下文无关文法

### 自顶向下的语法分析技术

### 自底向上的语法分析技术

### 语法分析器生成工具

## 语法制导翻译

## 中间代码生成

## 代码生成+优化
